
= Patient Information
:neo4j-version: 2.0.0-RC1
:author: Scott LePage
:tags: domain:healthcare, use-case:patient information


'''

*Table of Contents*

* *Database Setup*
** <<sample_data_set, Sample Data Set>>

'''

== Sample Data Set

//setup
[source,cypher]
----

// Create account holders
CREATE (person1:Person { 
       		FirstName: "John", 
       		LastName: "Smith", 
       		UniqueId: "0111111",
       		DOB: "1/1/1950",
       		Gender: "M",
       		Ethnicity: "Caucasian"})
       		
CREATE (person2:Person { 
       		FirstName: "Beverly", 
       		LastName: "Smith"}) 

CREATE (person3:Person { 
		FirstName: "Vera", 
		LastName: "Wang",
		UniqueId: "0222222",
       		DOB: "2/2/1970",
       		Gender: "F",
       		Ethnicity: "Chinese"}) 
		
CREATE (person4:Person { 
       		FirstName: "Tony", 
       		LastName: "Wang" 
       		}) 

CREATE (person5:Person { 
			FirstName: "Michael", 
			LastName: "Davies", 
			UniqueId: "910001" }) 
CREATE (person6:Person { 
			FirstName: "Stacy", 
			LastName: "Mulder", 
			UniqueId: "910002" }) 
			

// Create Address
//CREATE (address1:Address { 
//			Street: "123 NW 1st Street", 
//			City: "San Francisco", 
//			State: "California", 
//			ZipCode: "94101" })

// Connect spouses
CREATE (person1)-[:SPOUSE_OF]->(person2), 
       (person2)-[:SPOUSE_OF]->(person1),
       (person3)-[:SPOUSE_OF]->(person4),
       (person4)-[:SPOUSE_OF]->(person3)


// Create Phone Number
CREATE (phoneNumber1:PhoneNumber { PhoneNumber: "512-123-5678" })
CREATE (phoneNumber2:PhoneNumber { PhoneNumber: "832-123-5677" })

CREATE (person2)-[:HAS_PHONENUMBER]->(phoneNumber1), 
       (person4)-[:HAS_PHONENUMBER]->(phoneNumber2)

RETURN *
----

//graph

'''

== Entity Link Analysis

Performing entity link analysis on the above data model is demonstrated below.

==== Find account holders who share more than one piece of legitimate contact information

[source,cypher]
----
MATCH 		(accountHolder:AccountHolder)-[]->(contactInformation) 
WITH 		contactInformation, 
			count(accountHolder) AS RingSize 
MATCH 		(contactInformation)<-[]-(accountHolder) 
WITH 		collect(accountHolder.UniqueId) AS AccountHolders, 
			contactInformation, RingSize
WHERE 		RingSize > 1 
RETURN 		AccountHolders AS FraudRing, 
			labels(contactInformation) AS ContactType, 
			RingSize
ORDER BY 	RingSize DESC
----

//output
//table

==== Determine the financial risk of a possible fraud ring

[source,cypher]
----
MATCH 		(accountHolder:AccountHolder)-[]->(contactInformation) 
WITH 		contactInformation, 
			count(accountHolder) AS RingSize 
MATCH 		(contactInformation)<-[]-(accountHolder), 
			(accountHolder)-[r:HAS_CREDITCARD|HAS_UNSECUREDLOAN]->(unsecuredAccount)
WITH 		collect(DISTINCT accountHolder.UniqueId) AS AccountHolders, 
			contactInformation, RingSize,
			SUM(CASE type(r)
				WHEN 'HAS_CREDITCARD' THEN unsecuredAccount.Limit
				WHEN 'HAS_UNSECUREDLOAN' THEN unsecuredAccount.Balance
				ELSE 0
			END) as FinancialRisk
WHERE 		RingSize > 1
RETURN 		AccountHolders AS FraudRing, 
			labels(contactInformation) AS ContactType, 
			RingSize, 
			round(FinancialRisk) as FinancialRisk
ORDER BY 	FinancialRisk DESC
----

//output
//table
